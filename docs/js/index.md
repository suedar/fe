# 前端工程化

## 目的
1. 提高开发效率
2. 降低开发难度
3. 提高产品质量
4. 降低企业成本

## 怎么进行项目面试的准备
- star 

开头，“有段经历，正好遇到了这个问题……”。（讲清问题背景）

发展，“一般的做法是做不到的，因为……”。（讲问题的复杂性和挑战）

高潮，“我一开始用到……后来……”。（讲解决方案的形成过程）

结局，“成果是……”。（讲结果、影响、意义）


## diff 算法

### react 
基于同层级的进行对比
只进行删除与移动，不进行添加

  （一）Tree Diff算法:

Tree Diff 是两颗新旧虚拟树按照层级对应关系，把同一父节点的同一层级的节点遍历一遍，找到差异节点。

这种比较适用于DOM节点跨层级操作少的情形，这样就可以忽略不计层级带来的影响。它的分层比较，层级控制非常高效，当发现子节点不在了将会直接删除该节点以及它下面的所有子节点，也就是只需要遍历一遍。

  （二）Component Diff算法：

React构建的应用是以组件组合而成的，以组件为单位的差异对比策略也类似。

- 对于类型相同的组件，可以根据VDOM树按照原来的策略继续比较Tree即可。

- 对于类型不同的组件，React会将整个组件内部的所有的子节点重新替换。

  （三）Element Diff算法：

React在遇到类型相同的组件时，会继续对组件内部元素进行对比，检查内部元素的异同，这就是Element Diff。

不带key的组件，即使是相同节点，而且只是位移，还是需要删除并重写，无疑这种操作很繁琐并且低效。

在React中，可以给每个同层组件设置一个唯一的key，用来做标记。这样diff出不同的时候，只需要将节点集合进行位移即可。

具体的执行是，先将新节点集合进行遍历，然后通过唯一的key去老节点集合中寻找是否有命中的标记，如果有就执行移动操作。

- Tree diff：采用分层求异的策略，将新旧两棵DOM树按照层级关系进行比较，这样只需要遍历一遍，就能搞找到那些元素需要更新。
- Component diff：查看组件类型是否相同。如果类型不同，则需要更新，更新时先把旧组件删除，再创建一个新的组件插入之前删除的位置。
- Element diff：通过唯一key，对元素diff进行优化。元素发生了改变，则找到需要修改的元素，有针对性进行修改。

三、Fiber的算法：

(一）Fiber Reconciler 在阶段一进行 Diff 计算的时候，会生成一棵 Fiber 树。这棵树是在 Virtual DOM 树的基础上增加额外的信息来生成的，它本质来说是一个链表。

Fiber 树在首次渲染的时候会一次过生成。在后续需要 Diff 的时候，会根据已有树和最新 Virtual DOM 的信息，生成一棵新的树。这颗新树每生成一个新的节点，都会将控制权交回给主线程，去检查有没有优先级更高的任务需要执行。如果没有，则继续构建树的过程：

如果过程中有优先级更高的任务需要进行，则 Fiber Reconciler 会丢弃正在生成的树，在空闲的时候再重新执行一遍。

在构造 Fiber 树的过程中，Fiber Reconciler 会将需要更新的节点信息保存在Effect List当中，在阶段二执行的时候，会批量更新相应的节点。

（二）reconcile过程分为2个阶段（phase）：

（可中断）render/reconciliation 通过构造workInProgress tree得出change,    即requestIdleCallback 可以中断的

（不可中断）commit 应用这些DOM change  ，即commit   不可中断的，一口气完成。

（三）生命周期函数变了：

生命周期函数也被分为2个阶段了：

第1阶段的生命周期函数可能会被多次调用，默认以low优先级（后面介绍的6种优先级之一）执行，被高优先级任务打断的话，稍后重新执行


## 浏览器渲染

1. 解析 HTML 文件,构建 DOM 树,同时浏览器主进程负责下载 CSS 文件
2. CSS 文件下载完成,解析 CSS 文件成树形的数据结构,然后结合 DOM 树合并成 RenderObject 树
3. 布局 RenderObject 树 （Layout/reflow）,负责 RenderObject 树中的元素的尺寸,位置等计算
4. 绘制 RenderObject 树 （paint）,绘制页面的像素信息
5. 浏览器主进程将默认的图层和复合图层交给 GPU 进程,GPU 进程再将各个图层合成（composite）,最后显示出页面

https://segmentfault.com/a/1190000021517583

## vite 跟 webpack 的区别

webpack会先打包，然后启动开发服务器，请求服务器时直接给予打包结果。
而vite是直接启动开发服务器，请求哪个模块再对该模块进行实时编译。
由于现代浏览器本身就支持 ES Module，会自动向依赖的Module发出请求。vite充分利用这一点，将开发环境下的模块文件，就作为浏览器要执行的文件，而不是像webpack那样进行打包合并。
由于vite在启动的时候不需要打包，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。当浏览器请求某个模块时，再根据需要对模块内容进行编译。这种按需动态编译的方式，极大的缩减了编译时间，项目越复杂、模块越多，vite的优势越明显。
在HMR方面，当改动了一个模块后，仅需让浏览器重新请求该模块即可，不像webpack那样需要把该模块的相关依赖模块全部编译一次，效率更高。
当需要打包到生产环境时，vite使用传统的rollup进行打包，因此，vite的主要优势在开发阶段。另外，由于vite利用的是ES Module，因此在代码中不可以使用CommonJS
