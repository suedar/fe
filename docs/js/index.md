# 前端工程化

## 目的
1. 提高开发效率
2. 降低开发难度
3. 提高产品质量
4. 降低企业成本

## 怎么进行项目面试的准备
- star 

开头，“有段经历，正好遇到了这个问题……”。（讲清问题背景）

发展，“一般的做法是做不到的，因为……”。（讲问题的复杂性和挑战）

高潮，“我一开始用到……后来……”。（讲解决方案的形成过程）

结局，“成果是……”。（讲结果、影响、意义）


## diff 算法

### react 
基于同层级的进行对比
只进行删除与移动，不进行添加

  （一）Tree Diff算法:

Tree Diff 是两颗新旧虚拟树按照层级对应关系，把同一父节点的同一层级的节点遍历一遍，找到差异节点。

这种比较适用于DOM节点跨层级操作少的情形，这样就可以忽略不计层级带来的影响。它的分层比较，层级控制非常高效，当发现子节点不在了将会直接删除该节点以及它下面的所有子节点，也就是只需要遍历一遍。

  （二）Component Diff算法：

React构建的应用是以组件组合而成的，以组件为单位的差异对比策略也类似。

- 对于类型相同的组件，可以根据VDOM树按照原来的策略继续比较Tree即可。

- 对于类型不同的组件，React会将整个组件内部的所有的子节点重新替换。

  （三）Element Diff算法：

React在遇到类型相同的组件时，会继续对组件内部元素进行对比，检查内部元素的异同，这就是Element Diff。

不带key的组件，即使是相同节点，而且只是位移，还是需要删除并重写，无疑这种操作很繁琐并且低效。

在React中，可以给每个同层组件设置一个唯一的key，用来做标记。这样diff出不同的时候，只需要将节点集合进行位移即可。

具体的执行是，先将新节点集合进行遍历，然后通过唯一的key去老节点集合中寻找是否有命中的标记，如果有就执行移动操作。

- Tree diff：采用分层求异的策略，将新旧两棵DOM树按照层级关系进行比较，这样只需要遍历一遍，就能搞找到那些元素需要更新。
- Component diff：查看组件类型是否相同。如果类型不同，则需要更新，更新时先把旧组件删除，再创建一个新的组件插入之前删除的位置。
- Element diff：通过唯一key，对元素diff进行优化。元素发生了改变，则找到需要修改的元素，有针对性进行修改。

三、Fiber的算法：

(一）Fiber Reconciler 在阶段一进行 Diff 计算的时候，会生成一棵 Fiber 树。这棵树是在 Virtual DOM 树的基础上增加额外的信息来生成的，它本质来说是一个链表。

Fiber 树在首次渲染的时候会一次过生成。在后续需要 Diff 的时候，会根据已有树和最新 Virtual DOM 的信息，生成一棵新的树。这颗新树每生成一个新的节点，都会将控制权交回给主线程，去检查有没有优先级更高的任务需要执行。如果没有，则继续构建树的过程：

如果过程中有优先级更高的任务需要进行，则 Fiber Reconciler 会丢弃正在生成的树，在空闲的时候再重新执行一遍。

在构造 Fiber 树的过程中，Fiber Reconciler 会将需要更新的节点信息保存在Effect List当中，在阶段二执行的时候，会批量更新相应的节点。

（二）reconcile过程分为2个阶段（phase）：

（可中断）render/reconciliation 通过构造workInProgress tree得出change,    即requestIdleCallback 可以中断的

（不可中断）commit 应用这些DOM change  ，即commit   不可中断的，一口气完成。

（三）生命周期函数变了：

生命周期函数也被分为2个阶段了：

第1阶段的生命周期函数可能会被多次调用，默认以low优先级（后面介绍的6种优先级之一）执行，被高优先级任务打断的话，稍后重新执行


### vue

在新老虚拟DOM对比时：
● 首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换
● 如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)
● 比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。
● 匹配时，找到相同的子节点，递归比较子节点

在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。

## 浏览器渲染

1. 解析 HTML 文件,构建 DOM 树,同时浏览器主进程负责下载 CSS 文件
2. CSS 文件下载完成,解析 CSS 文件成树形的数据结构,然后结合 DOM 树合并成 RenderObject 树
3. 布局 RenderObject 树 （Layout/reflow）,负责 RenderObject 树中的元素的尺寸,位置等计算
4. 绘制 RenderObject 树 （paint）,绘制页面的像素信息
5. 浏览器主进程将默认的图层和复合图层交给 GPU 进程,GPU 进程再将各个图层合成（composite）,最后显示出页面

https://segmentfault.com/a/1190000021517583

## vite 跟 webpack 的区别

webpack会先打包，然后启动开发服务器，请求服务器时直接给予打包结果。
而vite是直接启动开发服务器，请求哪个模块再对该模块进行实时编译。
由于现代浏览器本身就支持 ES Module，会自动向依赖的Module发出请求。vite充分利用这一点，将开发环境下的模块文件，就作为浏览器要执行的文件，而不是像webpack那样进行打包合并。
由于vite在启动的时候不需要打包，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。当浏览器请求某个模块时，再根据需要对模块内容进行编译。这种按需动态编译的方式，极大的缩减了编译时间，项目越复杂、模块越多，vite的优势越明显。
在HMR方面，当改动了一个模块后，仅需让浏览器重新请求该模块即可，不像webpack那样需要把该模块的相关依赖模块全部编译一次，效率更高。
当需要打包到生产环境时，vite使用传统的rollup进行打包，因此，vite的主要优势在开发阶段。另外，由于vite利用的是ES Module，因此在代码中不可以使用CommonJS

## qiankun 实现原理
### css隔离
shadow DOM并不是一个特别新的概念，html中的video标签就是使用shadow DOM的一个案例。使用它时，你在html只会看到一个video标签，但实际上播放器上还有一系列按钮和其他操作，这些就都是封装到shadow dom中的，对外界是不可见的。所以Shadow DOM天然实现了样式隔离。

Dynamic Stylesheet
动态插入/移除样式DOM, 没错，这是一个及其简单的方式。原理是浏览器会对所有的样式表的插入、移除做整个 CSSOM 的重构，从而达到 插入、卸载 样式的目的：

### js隔离
#### 快照方式
下面是乾坤中关于快照隔离的代码。在创建微应用的时候会实例化一个沙盒对象，它有两个方法，active是在激活微应用的时候执行，而inactive是在离开微应用的时候执行。

整体的思路是在激活微应用时将当前的window对象拷贝存起来，然后从modifyPropsMap中恢复这个微应用上次修改的属性到window中。在离开微应用时会与原有的window对象做对比，将有修改的属性保存起来，以便再次进入这个微应用时进行数据恢复，然后把有修改的属性值恢复到以前的状态。

#### proxy方式

乾坤中关于proxy的隔离方式有两种，我们以最优的方案分析。下面中的代码省略了很多，只讲其中的原理。

微应用中的script内容都会加with(global)来执行，这里global是全局对象，如果是proxy的隔离方式那么他就是下面新创建的proxy对象。我们知道with可以改变里面代码的作用域，也就是我们的微应用全局对象会变成下面的这个proxy。当设置属性的时候会设置到proxy对象里，在读取属性时先从proxy里找，没找到再从原始的window中找。也就是你在微应用里修改全局对象的属性时不会在window中修改，而是在proxy对象中修改。因为不会破坏window对象，这样就会隔离各个应用之间的数据影响。


> http://blog.wangminghuan.cn/%E6%B5%85%E6%9E%90qiankun%E4%B8%AD%E7%9A%84%E6%A0%B7%E5%BC%8F%E9%9A%94%E7%A6%BB%E4%B8%8EJS%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6/


## jwt 的token构成

JWS是JWT的一种实现，除了JWS外，JWE(JSON Web Encryption)也是JWT的一种实现。JWE的生成过程较为复杂，虽保证了安全性，但是降低了访问效率，下面主要介绍JWT的一种实现方式--JWS。第一部分我们称它为头部（header),第二部分我们称其为载荷（payload)，第三部分是签证（signature)


> https://juejin.cn/post/6844903872868139015


## umi

Umi，中文可发音为乌米，是可扩展的企业级前端应用框架。Umi 以路由为基础的，同时支持配置式路由和约定式路由，保证路由的功能完备，并以此进行功能扩展。然后配以生命周期完善的插件体系，覆盖从源码到构建产物的每个生命周期，支持各种功能扩展和业务需求。
> react-router + webpack + babel

内置功能 qiankun dva esbuild 国际化能力 

## hooks 

hook的优点如下∶ 
● 使用直观；
● 解决hoc的prop 重名问题；
● 解决render props 因共享数据 而出现嵌套地狱的问题；
● 能在return之外使用数据的问题。

需要注意的是：hook只能在组件顶层使用，不可在分支语句中使用。

通过对比，从形态上可以对两种组件做区分，它们之间的区别如下：
● 类组件需要继承 class，函数组件不需要；
● 类组件可以访问生命周期方法，函数组件不能；
● 类组件中可以获取到实例化后的 this，并基于这个 this 做各种各样的事情，而函数组件不可以；
● 类组件中可以定义并维护 state（状态），而函数组件不可以；
函数组件就真正地将数据和渲染绑定到了一起。函数组件是一个更加匹配其设计理念、也更有利于逻辑拆分与重用的组件表达形式。

React Hooks 的限制主要有两条：
● 不要在循环、条件或嵌套函数中调用 Hook；
● 在 React 的函数组件中调用 Hook。

React Hooks在平时开发中需要注意的问题和原因
（1）不要在循环，条件或嵌套函数中调用Hook，必须始终在 React函数的顶层使用Hook
（2）使用useState时候，使用push，pop，splice等直接更改数组对象的坑


### useEffect useCallback useMemo 
useEffect可以帮助我们在DOM更新完成后执行某些副作用操作

useCallback 和 useMemo 
相同点：useCallback 和 useMemo 都是性能优化的手段，类似于类组件中的 shouldComponentUpdate，在子组件中使用 shouldComponentUpdate， 判定该组件的 props 和 state 是否有变化，从而避免每次父组件render时都去重新渲染子组件。
区别：useCallback 和 useMemo 的区别是useCallback返回一个函数，当把它返回的这个函数作为子组件使用时，可以避免每次父组件更新时都重新渲染这个子组件，

就算有比对代价也比较小，因为哪怕是对象也只是引用比较。我觉得任何时候都用是一个好的习惯，但是大部分时间不用也没什么大问题。但是如果该函数或变量作为 props 传给子组件，请一定要用，避免子组件的非必要渲染

> useCallback: 缓存回调函数，避免传入的回调每次都是新的函数实例而导致依赖组件重新渲染，具有性能优化的效果；
> useMemo: 用于缓存传入的 props，避免依赖的组件每次都重新渲染；

useCallback 钩子是专门为传递给子组件的回调函数设计的，可以避免不必要的重新创建这些函数，重新创建这些函数的过程会再每次重渲染时引起性能问题
useMemo 和 useCallback 接受的参数都是一样，都是在其依赖项发生变化后执行，都是返回缓存的值，区别在于 useMemo 返回的是函数运行的结果，useCallback 返回的是函数

## webpack 提高构建速度

thread-loader
parallel-webpack